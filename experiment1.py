import glob
import json
import argparse
from pprint import pprint
from distutils.util import strtobool
from datetime import datetime
from itertools import product

import numpy as np

from utils import dump_results
import sampling
import generate_appm

def bool_type(x):
  return bool(strtobool(x))

DEFAULT_SAMPLING_METHOD = "RandomWalkSampling"

def parse_graph_generate_args():
  parser = argparse.ArgumentParser("Experiment 1: Graph generation")

  parser.add_argument("--seed",
                      type=int,
                      default=None,
                      help="Random seed")

  parser.add_argument("--p",
                      type=float,
                      default=3e-1,
                      help=("Parameter p for assortative planted partition"
                            " model (APPM), specifying the probability that"
                            " two nodes i,j out of the same cluster are"
                            " connected by an edge"))

  parser.add_argument("--q",
                      type=float,
                      default=5e-2,
                      help=("Parameter p for assortative planted partition"
                            " model (APPM), specifying the probability that"
                            " two nodes i,j out of two different clusters are"
                            " connected by an edge"))

  parser.add_argument("--cluster_sizes",
                      type=int,
                      nargs='+',
                      default=[10, 20, 30, 40],
                      help=("Parameter p for assortative planted partition"
                            " model (APPM), specifying the probability that"
                            " two nodes i,j out of two different clusters are"
                            " connected by an edge"))

  parser.add_argument("--num_graphs",
                      type=int,
                      default=100,
                      help="Number of graphs to generate")

  parser.add_argument("--results_base",
                      default="./data/experiment1/graphs",
                      type=str,
                      help="Directory to write graphs to.")

  args, unknown = parser.parse_known_args()

  assert(len(unknown) <= 1)

  return vars(args)

def parse_sampling_args():
  parser = argparse.ArgumentParser("Experiment 1: Graph sampling")

  parser.add_argument("--seed",
                      type=int,
                      default=None,
                      help="Random seed")

  parser.add_argument("--Ls",
                      type=int,
                      nargs='+',
                      default=[20],
                      help=("Values for random walk length L to run experiments"
                            " for. The complete parameter space to run the"
                            " experiments for is generated by taking cartesian"
                            " product of Ls and other parameters (Ms)"))

  parser.add_argument("--Ms",
                      type=int,
                      nargs='+',
                      default=[10],
                      help=("Values for sampling budget M to run experiments"
                            " for. The complete parameter space to run the"
                            " experiments for is generated by taking cartesian"
                            " product of Ms and other parameters (Ls)"))


  parser.add_argument("--graph_file_pattern",
                      type=str,
                      default="./data/experiment1/graphs/*.json",
                      help=("Run experiment for the graphs matching the"
                            " file pattern. The pattern is passed to glob.glob"
                            "function"))

  parser.add_argument("--sampling_method",
                      type=str,
                      default=sampling.DEFAULT_SAMPLING_METHOD,
                      help=("Name of the class used for graph sampling. The"
                            " sampling class must be importable from"
                            "algorithms.sampling module. Defaults to '{0}',"
                            " i.e. algorithms.sampling.{0}."
                            "".format(sampling.DEFAULT_SAMPLING_METHOD)))

  parser.add_argument("--results_base",
                      default="./data/experiment1/samples",
                      type=str,
                      help="Directory to write graphs to.")

  args, unknown = parser.parse_known_args()

  assert(len(unknown) <= 1)

  return vars(args)


def parse_recovery_args():
  # TODO: implement this
  pass


ARGS_PARSERS = {
  "graph_generate": parse_graph_generate_args,
  "sampling": parse_sampling_args,
  "recovery": parse_recovery_args,
}

def parse_args():
  parser = argparse.ArgumentParser(
    description=(
      "Experiment 1 based on:\n"
      "Basirian, S. and Jung, A., 2017."
      " Random Walk Sampling for Big Data over Networks."
      " arXiv preprint arXiv:1704.04799."))

  parser.add_argument("-v", "--verbose",
                      type=bool_type,
                      default=False,
                      help="Verbose")

  # TODO: add choices for --step
  parser.add_argument("--step",
                      type=str,
                      default="graph_generate",
                      help="Step of the pipeline to run")

  args, unknown = parser.parse_known_args()

  return vars(args)

def run_graph_generate(args):
  print("graph_generate")
  generate_args_base = {
    "sizes": args["cluster_sizes"],
    "p_in": args["p"],
    "p_out": args["q"],
    "seed": args["seed"],
    "visualize": False,
  }
  num_graphs = args["num_graphs"]
  for i in range(num_graphs):
    out_path = (f"{args['results_base']}"
                f"/{i:0{len(str(num_graphs))-1}}.json")
    generate_args = generate_args_base.copy()
    generate_args.update({"out_path": out_path})

    print(f"{i}: {generate_args}")

    generate_appm.main(generate_args)

def run_sampling(args):
  print("sampling")

  sampling_args_base = { "seed": args["seed"] }

  for filename in glob.glob(args["graph_file_pattern"]):
    for L, M in product(args["Ls"], args["Ms"]):
      print("filename: ", filename)

      sampling_args = sampling_args_base.copy()
      sampling_args.update({
        "graph_file": filename,
        "sampling_method": args["sampling_method"],
        "sampling_params": {
          "L": L,
          "M": M
        },
        "results_file": (f"{args['results_base']}"
                         f"/{L}-{M}-{filename.split('/')[-1]}")
      })

      print(f"{sampling_args}")

      sampling.main(sampling_args)

def recovery(args):
  pass

def main(args):
  print(args)
  step = args["step"]
  if step == "graph_generate":
    run_graph_generate(args)
  elif step == "sampling":
    run_sampling(args)
  elif step == "recovery":
    run_recovery(args)
  return
  sampling_method_name = args["sampling_method"]
  sampling_params = args["sampling_params"]
  graph_file = args["graph_file"]

  SamplingMethodClass = getattr(sampling, sampling_method_name)
  sampling_method = SamplingMethodClass(graph_file, sampling_params)

  results = args.copy()

  run_results = sampling_method.run()

  results.update(run_results)

  results_file = args.get("results_file")
  if results_file is not None:
    dump_results(results, results_file)
  else:
    pprint(results)

if __name__ == "__main__":
  args = parse_args()
  args.update(ARGS_PARSERS[args["step"]]())
  main(args)
